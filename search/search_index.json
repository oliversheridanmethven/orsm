{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#author","title":"Author","text":"<p>Dr Oliver Sheridan-Methven  oliver.sheridan-methven@hotmail.co.uk.</p>"},{"location":"index.html#description","title":"Description","text":"<p>A collection of various code snippets that are frequently  useful (or entertaining). </p>"},{"location":"index.html#documentation","title":"Documentation","text":"<p>The full documentation can be found here: Documentation.</p>"},{"location":"LICENSE.html","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Dr Oliver Sheridan-Methven</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"documentation/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>orsm<ul> <li>cli<ul> <li>cli</li> <li>repo</li> </ul> </li> <li>combinations<ul> <li>combinations</li> </ul> </li> <li>decorators<ul> <li>disabling</li> <li>nullifying</li> </ul> </li> <li>logger<ul> <li>logger</li> </ul> </li> <li>outputs<ul> <li>suppressors</li> </ul> </li> <li>profilers<ul> <li>memory<ul> <li>memory_profilers</li> </ul> </li> <li>time<ul> <li>time_profilers</li> </ul> </li> </ul> </li> <li>timing<ul> <li>timing</li> </ul> </li> <li>variables<ul> <li>variables</li> </ul> </li> </ul> </li> </ul>"},{"location":"documentation/orsm/cli/cli.html","title":"cli","text":"<p>Tools for constructing a nice CLI.</p>"},{"location":"documentation/orsm/cli/cli.html#orsm.cli.cli.PathToDir","title":"<code>PathToDir</code>","text":"<p>               Bases: <code>Action</code></p> <p>Checks a paths point to an existing directory.</p> Source code in <code>src/orsm/cli/cli.py</code> <pre><code>class PathToDir(argparse.Action):\n    \"\"\"\n    Checks a paths point to an existing directory.\n    \"\"\"\n    def __call__(self, parser, args, values, option_string=None):\n        assert isinstance(values, str) and str\n        file_path = Path(values)\n        assert file_path.exists(), f\"{file_path = } does not exist.\"\n        assert file_path.is_dir(), f\"{file_path = } is not a directory.\"\n        setattr(args, self.dest, file_path)\n</code></pre>"},{"location":"documentation/orsm/cli/cli.html#orsm.cli.cli.PathToFile","title":"<code>PathToFile</code>","text":"<p>               Bases: <code>Action</code></p> <p>Checks a paths point to an existing file.</p> Source code in <code>src/orsm/cli/cli.py</code> <pre><code>class PathToFile(argparse.Action):\n    \"\"\"\n    Checks a paths point to an existing file.\n    \"\"\"\n    def __call__(self, parser, args, values, option_string=None):\n        assert isinstance(values, str) and str\n        file_path = Path(values)\n        assert file_path.exists(), f\"{file_path = } does not exist.\"\n        assert file_path.is_file(), f\"{file_path = } is not a file.\"\n        setattr(args, self.dest, file_path)\n</code></pre>"},{"location":"documentation/orsm/cli/cli.html#orsm.cli.cli.setup_standard_parser","title":"<code>setup_standard_parser(*argparse_args, **argparse_kwargs)</code>","text":"<p>Sets up a standard argument parser.</p> <p>Parameters:</p> Name Type Description Default <code>argparse_args</code> <p>Positional combinations passed to the parser.</p> <code>()</code> <code>argparse_kwargs</code> <p>Keyword combinations passed to the parser.</p> <code>{}</code> <p>Returns:</p> Type Description <code>argparse.ArgumentParser :</code> <p>An argument parser.</p> Source code in <code>src/orsm/cli/cli.py</code> <pre><code>def setup_standard_parser(*argparse_args, **argparse_kwargs) -&gt; argparse.ArgumentParser:\n    \"\"\"\n    Sets up a standard argument parser.\n\n    Parameters\n    ----------\n    argparse_args :\n        Positional combinations passed to the parser.\n    argparse_kwargs :\n        Keyword combinations passed to the parser.\n\n    Returns\n    -------\n    argparse.ArgumentParser :\n        An argument parser.\n\n    \"\"\"\n    epilogue = dedent(f\"\"\"\n    Version: \n        {repo.repo_name()} {repo.repo_version()}\n\n    Author: \n        {repo.repo_author()}\n\n    Maintained by: \n        {repo.repo_author()}\n        &lt;{repo.repo_email()}&gt;\n    \"\"\")\n    parser = argparse.ArgumentParser(*argparse_args, **argparse_kwargs, formatter_class=HelpFormatter, allow_abbrev=False, epilog=epilogue)\n    parser.add_argument(\"--version\", help=\"Show the version of this program.\", action=ShowVersion, nargs=0)\n    # How we want to control the logging.\n    parser.add_argument(\"--trace\", help=\"Enable program tracing. Extremely verbose!\", action=set_verbosity_level(logging.TRACE), nargs=0)\n    parser.add_argument(\"--debug\", help=\"Enable debug logging. Very verbose!\", action=set_verbosity_level(logging.DEBUG), nargs=0)\n    parser.add_argument(\"--verbose\", help=\"Enable verbose logging. Quite verbose!\", action=set_verbosity_level(logging.INFO), nargs=0)\n    parser.add_argument(\"--quiet\", help=\"Supress all logging. Quite quiet!\", action=set_verbosity_level(logging.WARNING), nargs=0)\n    parser.add_argument(\"--silent\", help=\"Suppress most logging and output. Absolutely silent!\", action=set_verbosity_level(logging.ERROR), nargs=0)\n    parser.add_argument(\"--log_files\", type=str, metavar=\"FILENAME\", help=\"Store log output to files. Split into regular output and error output.\", action=SetLogFileAction, nargs=\"?\")\n    parser.add_argument(\"--suppress_console_output\", help=\"Whether to suppress output to the console.\", action=SetConsoleSuppression, nargs=0)\n    parser.add_argument(\"--profiling\", help=\"Show results from profilers\", action=SetProfiling, nargs=0)\n    return parser\n</code></pre>"},{"location":"documentation/orsm/cli/cli.html#orsm.cli.cli.standard_parse","title":"<code>standard_parse(*argparse_args, **argparse_kwargs)</code>","text":"<p>Perform a standard parse.</p> <p>Parameters:</p> Name Type Description Default <code>argparse_args</code> <p>Positional combinations passed to the parser.</p> <code>()</code> <code>argparse_kwargs</code> <p>Keyword combinations passed to the parser.</p> <code>{}</code> <p>Returns:</p> Type Description <code>argparse.Namespace :</code> <p>The namespace generated from the standard parse.</p> Source code in <code>src/orsm/cli/cli.py</code> <pre><code>def standard_parse(*argparse_args, **argparse_kwargs) -&gt; argparse.Namespace:\n    \"\"\"\n    Perform a standard parse.\n\n    Parameters\n    ----------\n    argparse_args :\n        Positional combinations passed to the parser.\n    argparse_kwargs :\n        Keyword combinations passed to the parser.\n\n    Returns\n    -------\n    argparse.Namespace :\n        The namespace generated from the standard parse.\n\n    \"\"\"\n    parser = setup_standard_parser(*argparse_args, **argparse_kwargs)\n    return parser.parse_args()\n</code></pre>"},{"location":"documentation/orsm/cli/cli.html#orsm.cli.cli.unit_test_parse","title":"<code>unit_test_parse(*argparse_args, **argparse_kwargs)</code>","text":"<p>Parse command line ahead of forwarding onto the unittests.</p> Notes <p>To allow our command line combinations to be parsed ahead of running unit tests. Useful for logging. Taken from: https://stackoverflow.com/a/44248445/5134817</p> <p>Parameters:</p> Name Type Description Default <code>argparse_args</code> <p>Positional combinations passed to the parser.</p> <code>()</code> <code>argparse_kwargs</code> <p>Keyword combinations passed to the parser.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> Source code in <code>src/orsm/cli/cli.py</code> <pre><code>def unit_test_parse(*argparse_args, **argparse_kwargs) -&gt; None:\n    \"\"\"\n    Parse command line ahead of forwarding onto the unittests.\n\n    Notes\n    -----\n    To allow our command line combinations to be parsed ahead of running unit tests. Useful for logging.\n    Taken from: https://stackoverflow.com/a/44248445/5134817\n\n    Parameters\n    ----------\n    argparse_args :\n        Positional combinations passed to the parser.\n    argparse_kwargs :\n        Keyword combinations passed to the parser.\n\n    Returns\n    -------\n    None :\n\n    \"\"\"\n    import sys\n    import unittest\n    parser = setup_standard_parser(*argparse_args, **argparse_kwargs)\n    ns, parsed_args = parser.parse_known_args(namespace=unittest)\n    sys.argv[:] = sys.argv[:1] + parsed_args\n</code></pre>"},{"location":"documentation/orsm/cli/repo.html","title":"repo","text":"<p>Information about this repository.</p>"},{"location":"documentation/orsm/cli/repo.html#orsm.cli.repo.repo_author","title":"<code>repo_author()</code>","text":"<p>The author of this repository.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The author of this repository.</p> Source code in <code>src/orsm/cli/repo.py</code> <pre><code>def repo_author() -&gt; str:\n    \"\"\"\n    The author of this repository.\n\n    Returns\n    -------\n    str :\n        The author of this repository.\n    \"\"\"\n    return \"Dr Oliver Sheridan-Methven\"\n</code></pre>"},{"location":"documentation/orsm/cli/repo.html#orsm.cli.repo.repo_email","title":"<code>repo_email()</code>","text":"<p>The email for this repository.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The email for this repository.</p> Source code in <code>src/orsm/cli/repo.py</code> <pre><code>def repo_email() -&gt; str:\n    \"\"\"\n    The email for this repository.\n\n    Returns\n    -------\n    str:\n        The email for this repository.\n    \"\"\"\n    return \"oliver.sheridan-methven@hotmail.co.uk\"\n</code></pre>"},{"location":"documentation/orsm/cli/repo.html#orsm.cli.repo.repo_name","title":"<code>repo_name()</code>","text":"<p>The name of this repository.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the repository.</p> Source code in <code>src/orsm/cli/repo.py</code> <pre><code>def repo_name() -&gt; str:\n    \"\"\"\n    The name of this repository.\n\n    Returns\n    -------\n    str:\n        The name of the repository.\n\n    \"\"\"\n    return \"orsm\"\n</code></pre>"},{"location":"documentation/orsm/cli/repo.html#orsm.cli.repo.repo_version","title":"<code>repo_version()</code>","text":"<p>The version of this repository.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The version of this repository.</p> Source code in <code>src/orsm/cli/repo.py</code> <pre><code>def repo_version() -&gt; str:\n    \"\"\"\n    The version of this repository.\n\n    Returns\n    -------\n    str:\n        The version of this repository.\n    \"\"\"\n    from orsm._version import version\n    return version\n</code></pre>"},{"location":"documentation/orsm/combinations/combinations.html","title":"combinations","text":"<p>Handling combinations.</p>"},{"location":"documentation/orsm/combinations/combinations.html#orsm.combinations.combinations.all_combinations","title":"<code>all_combinations(iterable, *, min_length=None, max_length=None)</code>","text":"<p>Generates the possible cross product of combinations.</p> Example <pre><code>&gt;&gt;&gt; all_combinations([\"a\",\"b\",\"c\"])\n[(),\n ('a',),\n ('b',),\n ('c',),\n ('a', 'b'),\n ('a', 'c'),\n ('b', 'c'),\n ('a', 'b', 'c')]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable</code> <p>Object to iterate over.</p> required <code>min_length</code> <code>int</code> <p>Minimum length of combinations.</p> <code>None</code> <code>max_length</code> <code>int</code> <p>Maximum length of combinations.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Iterable]:</code> <p>The cross product of combinations.</p> Source code in <code>src/orsm/combinations/combinations.py</code> <pre><code>def all_combinations(iterable: Iterable, *, min_length: int = None, max_length: int = None) -&gt; List[Iterable]:\n    \"\"\"\n    Generates the possible cross product of combinations.\n\n    Example\n    -------\n        &gt;&gt;&gt; all_combinations([\"a\",\"b\",\"c\"])\n        [(),\n         ('a',),\n         ('b',),\n         ('c',),\n         ('a', 'b'),\n         ('a', 'c'),\n         ('b', 'c'),\n         ('a', 'b', 'c')]\n\n    Parameters\n    ----------\n    iterable :\n        Object to iterate over.\n    min_length :\n        Minimum length of combinations.\n    max_length :\n        Maximum length of combinations.\n\n    Returns\n    -------\n    List[Iterable]:\n        The cross product of combinations.\n    \"\"\"\n    for variable, value in variable_names_and_objects(max_length, min_length):\n        if value is not None:\n            assert isinstance(value, int) and value &gt;= 0, f\"The {variable = } needs to be a positive integer, not {value = }\"\n    if all([i is not None for i in [min_length, max_length]]):\n        assert min_length &lt;= max_length, f\"The bounding lengths contradict: {max_length = } and {min_length = }\"\n    size = 0\n    reached_max_size = False\n\n    while (max_length is not None and size &lt;= max_length) or (max_length is None and not reached_max_size):\n        if max_length is None:\n            # We will have to determine when to stop\n            iterable_size = len(iterable)\n            reached_max_size = (size == iterable_size)\n        if min_length is None or size &gt;= min_length:\n            yield from itertools.combinations(iterable, size)\n        size += 1\n</code></pre>"},{"location":"documentation/orsm/combinations/combinations.html#orsm.combinations.combinations.all_kwarg_combinations","title":"<code>all_kwarg_combinations(*, keys, values, min_length=None, max_length=None)</code>","text":"<p>For a list of keys and values it produces all the unique combinations of key-value pairings.</p> Notes <p>This is quite useful in unit tests for combinations of possible combinations.</p> Example <pre><code>&gt;&gt;&gt; all_kwarg_combinations(keys=[\"a\", \"b\"], values=[1, 2])\n[{},\n {'a': 1},\n {'a': 2},\n {'b': 1},\n {'b': 2},\n {'a': 1, 'b': 1},\n {'a': 1, 'b': 2},\n {'a': 2, 'b': 1},\n {'a': 2, 'b': 2}]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List</code> <p>The keys to use.</p> required <code>values</code> <code>List</code> <p>The values to use.</p> required <code>min_length</code> <code>int</code> <p>The minimum length of combinations.</p> <code>None</code> <code>max_length</code> <code>int</code> <p>The maximum length of combinations.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Iterable]:</code> <p>The cross product of keys and values.</p> Source code in <code>src/orsm/combinations/combinations.py</code> <pre><code>def all_kwarg_combinations(*, keys: List, values: List, min_length:int=None, max_length:int=None) -&gt; List[Iterable]:\n    \"\"\"\n    For a list of keys and values it produces\n    all the unique combinations of key-value pairings.\n\n    Notes\n    -----\n    This is quite useful in unit tests for combinations of possible\n    combinations.\n\n    Example\n    -------\n        &gt;&gt;&gt; all_kwarg_combinations(keys=[\"a\", \"b\"], values=[1, 2])\n        [{},\n         {'a': 1},\n         {'a': 2},\n         {'b': 1},\n         {'b': 2},\n         {'a': 1, 'b': 1},\n         {'a': 1, 'b': 2},\n         {'a': 2, 'b': 1},\n         {'a': 2, 'b': 2}]\n\n\n\n    Parameters\n    ----------\n    keys :\n        The keys to use.\n    values :\n        The values to use.\n    min_length :\n        The minimum length of combinations.\n    max_length :\n        The maximum length of combinations.\n\n    Returns\n    -------\n    List[Iterable]:\n        The cross product of keys and values.\n    \"\"\"\n    individual_pairings = [list(itertools.product([key], values)) for key in keys]\n    combinations = all_combinations(individual_pairings, min_length=min_length, max_length=max_length)\n    yield from (dict(kwarg) for combination in combinations for kwarg in itertools.product(*combination))\n</code></pre>"},{"location":"documentation/orsm/decorators/disabling.html","title":"disabling","text":"<p>Decorators and things.</p>"},{"location":"documentation/orsm/decorators/disabling.html#orsm.decorators.disabling.disable_decorator","title":"<code>disable_decorator(should_disable, /, *predicate_args, reason=None, notify=True, **predicate_kwargs)</code>","text":"<p>Disable a decorator if a condition is met.</p> <p>Parameters:</p> Name Type Description Default <code>should_disable</code> <code>bool | Callable</code> <p>A bool or predicate function to determine if the decorator should be disabled.</p> required <code>predicate_args</code> <p>Positional combinations to provide to the predicate function.</p> <code>()</code> <code>reason</code> <code>str</code> <p>An reason to explain why the predicate might have been disabled.</p> <code>None</code> <code>notify</code> <code>bool</code> <p>Whether we should notify the user when the predicate has been disabled.</p> <code>True</code> <code>predicate_kwargs</code> <p>Keyword combinations to provide to the predicate function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>The conditional decorator.</p> Source code in <code>src/orsm/decorators/disabling.py</code> <pre><code>def disable_decorator(should_disable: bool | Callable, /, *predicate_args, reason: str = None, notify: bool = True, **predicate_kwargs) -&gt; Callable:\n    \"\"\"\n    Disable a decorator if a condition is met.\n\n    Parameters\n    ----------\n    should_disable :\n        A bool or predicate function to determine if the decorator should be disabled.\n    predicate_args :\n        Positional combinations to provide to the predicate function.\n    reason :\n        An reason to explain why the predicate might have been disabled.\n    notify :\n        Whether we should notify the user when the predicate has been disabled.\n    predicate_kwargs :\n        Keyword combinations to provide to the predicate function.\n\n    Returns\n    -------\n    Callable:\n        The conditional decorator.\n    \"\"\"\n    location = traceback.extract_stack()[-2]\n\n    def notification(decorator):\n        if notify:\n            logging.debug(f\"Disabling the decorator: {decorator.__name__} (decoration at {location.filename}:{location.lineno}) because: {reason}\")\n\n    def _nullify_decorator(decorator):\n        notification(decorator)\n        return nullify_decorator(null_decorator)\n\n    # For \"static\" condition checking.\n    if isinstance(should_disable, bool):\n        return _nullify_decorator if should_disable else null_decorator\n\n    # For \"runtime\" condition checking.\n    assert callable(should_disable), f\"Require a callable predicate: {should_disable =}\"\n\n    def conditionally_null_decorator(decorator):\n        enabled_decorator = disable_decorator(False, reason=reason, notify=False)(decorator)\n        disabled_decorator = disable_decorator(True, reason=reason, notify=False)(decorator)\n\n        def conditional_decorator(func):\n            @wraps(func)\n            def wrapper(*args, **kwargs):\n                logging.debug(\"Inside the conditional decorator\")\n                runtime_disable = should_disable(*predicate_args, **predicate_kwargs)\n                if runtime_disable:\n                    notification(decorator)\n                dec_func = disabled_decorator(func) if runtime_disable else enabled_decorator(func)\n                return dec_func(*args, **kwargs)\n\n            return wrapper\n\n        return conditional_decorator\n\n    return conditionally_null_decorator\n</code></pre>"},{"location":"documentation/orsm/decorators/nullifying.html","title":"nullifying","text":"<p>Nullifying decorators.</p>"},{"location":"documentation/orsm/decorators/nullifying.html#orsm.decorators.nullifying.null_decorator","title":"<code>null_decorator(func)</code>","text":"<p>A decorator that does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to be decorated.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/orsm/decorators/nullifying.py</code> <pre><code>def null_decorator(func: Callable) -&gt; Callable:\n    \"\"\"\n    A decorator that does nothing.\n\n    Parameters\n    ----------\n    func :\n        The function to be decorated.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"documentation/orsm/decorators/nullifying.html#orsm.decorators.nullifying.nullify_decorator","title":"<code>nullify_decorator(decorator)</code>","text":"<p>Nullifies a decorator.</p> <p>Parameters:</p> Name Type Description Default <code>decorator</code> <code>Callable</code> <p>The decorator to be nullified.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>A null decorator.</p> Source code in <code>src/orsm/decorators/nullifying.py</code> <pre><code>def nullify_decorator(decorator: Callable) -&gt; Callable:\n    \"\"\"\n    Nullifies a decorator.\n\n    Parameters\n    ----------\n    decorator :\n        The decorator to be nullified.\n\n    Returns\n    -------\n    Callable :\n        A null decorator.\n\n    \"\"\"\n    return null_decorator\n</code></pre>"},{"location":"documentation/orsm/logger/logger.html","title":"logger","text":"<p>Some wrapping around the default logging module.</p> <p>Exports <code>log</code> as our alias for the usual logging module. Users are encouraged to using the following alias.</p> <p>from osrm.logger.logger import log as logging</p>"},{"location":"documentation/orsm/outputs/suppressors.html","title":"suppressors","text":"<p>Handling output.</p>"},{"location":"documentation/orsm/outputs/suppressors.html#orsm.outputs.suppressors.Suppressor","title":"<code>Suppressor</code>","text":"<p>A class to suppress printing output.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with Suppressor(): print(\"something\")\n</code></pre> Source code in <code>src/orsm/outputs/suppressors.py</code> <pre><code>class Suppressor:\n    \"\"\"\n    A class to suppress printing output.\n\n    Examples\n    --------\n\n        &gt;&gt;&gt; with Suppressor(): print(\"something\")\n    \"\"\"\n\n    def __init__(self, *, suppress_output: bool = True):\n        self.suppress_output = suppress_output\n\n    def __enter__(self):\n        if self.suppress_output:\n            # The only method I have found which can\n            # suppress all output from Python and C\n            # extensions is to have the a C extension\n            # do all the redirection of stdout/stderr.\n            #\n            # It is the C extensions which case all the problems!\n            self.capture = py.io.StdCaptureFD()  # Captures everything from Python\n\n    def __exit__(self, *args):\n        if self.suppress_output:\n            self.capture.reset()\n</code></pre>"},{"location":"documentation/orsm/profilers/memory/memory_profilers.html","title":"memory_profilers","text":"<p>Memory profiler.</p>"},{"location":"documentation/orsm/profilers/memory/memory_profilers.html#orsm.profilers.memory.memory_profilers.profile_memory","title":"<code>profile_memory(func)</code>","text":"<p>Decorator to profile a function's memory usage.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to be profiled.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>The decorated function.</p> Source code in <code>src/orsm/profilers/memory/memory_profilers.py</code> <pre><code>@disable_decorator(cli.profiling_disabled, reason=\"Memory profiling has not been enabled from the command line.\")\ndef profile_memory(func: Callable) -&gt; Callable:\n    \"\"\"\n    Decorator to profile a function's memory usage.\n\n    Parameters\n    ----------\n    func :\n        The function to be profiled.\n\n    Returns\n    -------\n    Callable:\n        The decorated function.\n\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        tracemalloc.start()\n        result = func(*args, **kwargs)\n        current, peak = tracemalloc.get_traced_memory()\n        tracemalloc.stop()\n        logging.debug(f'Memory usage for {func.__name__}: Current={current / 10 ** 6}MB, Peak={peak / 10 ** 6}MB')\n        memory_profiler.store(name=func.__name__, peak=peak)\n        return result\n\n    return wrapper\n</code></pre>"},{"location":"documentation/orsm/profilers/time/time_profilers.html","title":"time_profilers","text":"<p>Time profilers.</p>"},{"location":"documentation/orsm/profilers/time/time_profilers.html#orsm.profilers.time.time_profilers.profile_time","title":"<code>profile_time(func)</code>","text":"<p>Decorator for profiling the time inside a function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to be decorated.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>The decorated function.</p> Notes <pre><code>Implementations using LineProfiler do not work in\ndebug mode, so may be disabled in such cases.\nThe debugger used in e.g. Pycharm requires\nsys.settrace (cf. https://github.com/pyutils/line_profiler/issues/276),\nbut that's what LineProfiler uses and it upsets everything,\nso we may disable this in debug mode.\n</code></pre> Source code in <code>src/orsm/profilers/time/time_profilers.py</code> <pre><code>@disable_decorator(cli.profiling_disabled, reason=\"Time profiling has not been enabled from the command line.\")\n@disable_decorator(is_in_debugger, reason=\"Time profiling disabled in debug mode.\")\ndef profile_time(func: Callable) -&gt; Callable:\n    \"\"\"\n    Decorator for profiling the time inside a function.\n\n    Parameters\n    ----------\n    func :\n        The function to be decorated.\n\n    Returns\n    -------\n    Callable :\n        The decorated function.\n\n    Notes\n    -----\n        Implementations using LineProfiler do not work in\n        debug mode, so may be disabled in such cases.\n        The debugger used in e.g. Pycharm requires\n        sys.settrace (cf. https://github.com/pyutils/line_profiler/issues/276),\n        but that's what LineProfiler uses and it upsets everything,\n        so we may disable this in debug mode.\n    \"\"\"\n\n    @wraps(func)\n    def profiled_function(*args, **kwargs):\n        time_profiler.add_function(func)\n        time_profiler.enable_by_count()\n        return func(*args, **kwargs)\n\n    return profiled_function\n</code></pre>"},{"location":"documentation/orsm/timing/timing.html","title":"timing","text":"<p>Timing functionality.</p>"},{"location":"documentation/orsm/timing/timing.html#orsm.timing.timing.Timeout","title":"<code>Timeout</code>","text":"<p>A nice timeout handler for with statements.</p> Notes <p>Taken from:     - https://stackoverflow.com/a/49567288/5134817     - https://www.youtube.com/watch?v=vGWSdp9dyhI</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with Timeout(timeout=5): time.sleep(2)\n</code></pre> Source code in <code>src/orsm/timing/timing.py</code> <pre><code>class Timeout:\n    \"\"\"\n    A nice timeout handler for with statements.\n\n    Notes\n    -----\n\n    Taken from:\n        - https://stackoverflow.com/a/49567288/5134817\n        - https://www.youtube.com/watch?v=vGWSdp9dyhI\n\n    Examples\n    --------\n\n        &gt;&gt;&gt; with Timeout(timeout=5): time.sleep(2)\n\n    \"\"\"\n    # TODO: Make this into a nice decorator perhaps\n\n    max_limit = 60  # Anything more than this is a ridiculous code smell.\n\n    def __init__(self, timeout: int = None, *, error_message: str = None):\n        if error_message is None:\n            error_message = 'Timed out after {} seconds.'.format(timeout)\n        if timeout is not None:\n            assert isinstance(timeout, int) and 0 &lt; timeout &lt;= self.max_limit, f\"The timeout {timeout = } is not valid.\"\n        self.timeout = timeout\n        self.error_message = error_message\n\n    def handle_timeout(self, signum, frame):\n        raise TimeoutError(self.error_message)\n\n    def __enter__(self):\n        if self.timeout:\n            self.orig_handler = signal.signal(signal.SIGALRM, self.handle_timeout)\n            signal.alarm(self.timeout)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.timeout:\n            signal.alarm(0)\n            signal.signal(signal.SIGALRM, self.orig_handler)\n</code></pre>"},{"location":"documentation/orsm/timing/timing.html#orsm.timing.timing.time_function","title":"<code>time_function(*function_args, name=None, function, iter_limit=None, time_limit=None, max_time_limit=None, suppress_output=False, print_timing_results=True, **function_kwargs)</code>","text":"<p>A basic function timer.</p> <p>Parameters:</p> Name Type Description Default <code>function_args</code> <p>Positional arguments passed to the function.</p> <code>()</code> <code>name</code> <code>str</code> <p>Name of the function.</p> <code>None</code> <code>function</code> <code>Callable</code> <p>The function to execute.</p> required <code>iter_limit</code> <code>int</code> <p>Maximum number of iterations.</p> <code>None</code> <code>time_limit</code> <code>int</code> <p>The time limit (seconds).</p> <code>None</code> <code>max_time_limit</code> <code>int</code> <p>The maximum time limit (seconds).</p> <code>None</code> <code>suppress_output</code> <code>bool</code> <p>Whether to suppress the output of the function.</p> <code>False</code> <code>print_timing_results</code> <code>bool</code> <p>Whether to show the timing results.</p> <code>True</code> <code>function_kwargs</code> <p>The keyword arguments passed to the function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>The timing results.</p> Source code in <code>src/orsm/timing/timing.py</code> <pre><code>def time_function(*function_args,\n                  name: str = None,\n                  function: Callable,\n                  iter_limit: int = None,\n                  time_limit: int = None,\n                  max_time_limit: int = None,\n                  suppress_output: bool = False,\n                  print_timing_results: bool = True,\n                  **function_kwargs) -&gt; Dict:\n    \"\"\"\n    A basic function timer.\n\n    Parameters\n    ----------\n    function_args :\n        Positional arguments passed to the function.\n    name :\n        Name of the function.\n    function :\n        The function to execute.\n    iter_limit :\n        Maximum number of iterations.\n    time_limit :\n        The time limit (seconds).\n    max_time_limit :\n        The maximum time limit (seconds).\n    suppress_output :\n        Whether to suppress the output of the function.\n    print_timing_results :\n        Whether to show the timing results.\n    function_kwargs :\n        The keyword arguments passed to the function.\n\n    Returns\n    -------\n    Dict :\n        The timing results.\n\n    \"\"\"\n    name = name if name else function.__name__\n    total_iterations = 0\n    iterations = 1\n    seconds = 0\n\n    for variable, value in variable_names_and_objects(iter_limit, time_limit, max_time_limit):\n        if value:\n            assert isinstance(value, int) and 1 &lt;= value, f\"The {variable = } has an invalid {value = }\"\n\n    if not iter_limit and not time_limit:\n        time_limit = max_time_limit if max_time_limit else 0.1\n\n    iteration_growth_factor = 2\n    if not max_time_limit and time_limit:\n        max_time_limit = 2 * iteration_growth_factor * time_limit\n\n    with Timeout(timeout=max_time_limit):\n        with Suppressor(suppress_output=suppress_output):\n            while (time_limit and seconds &lt; time_limit) or (iter_limit and total_iterations &lt; iter_limit):\n                remaining_iterations = iterations if not iter_limit else min(iterations, iter_limit - total_iterations)\n                start = time.time()  # We include the for loop in our timing, hoping it is negligible.\n                if not remaining_iterations:\n                    break\n                for i in range(remaining_iterations):\n                    function(*function_args, **function_kwargs)\n                end = time.time()\n                seconds += end - start\n                total_iterations += remaining_iterations\n                iterations *= iteration_growth_factor\n                iterations = int(iterations)\n                assert iterations, \"There are no iterations to be done.\"\n    average = seconds / total_iterations\n    if print_timing_results:\n        print(f\"The function {name} took {seconds} seconds over {total_iterations} iterations, averaging {average} seconds per function call.\")\n    return {\"name\": name, \"seconds\": seconds, \"total_iterations\": total_iterations, \"average\": average}\n</code></pre>"},{"location":"documentation/orsm/variables/variables.html","title":"variables","text":"<p>Variable mangling.</p>"},{"location":"documentation/orsm/variables/variables.html#orsm.variables.variables.variable_names_and_objects","title":"<code>variable_names_and_objects: Iterable = return_dict_items(jsobj, vars_only=False, frame=2)</code>  <code>module-attribute</code>","text":"<p>Will return the names of the variables as entered and their underlying objects.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a, b, c = 1, 2, 3\n&gt;&gt;&gt; for k, v in variable_names_and_objects(a, b, c): print(k, v)\n(\"a\", 1)\n(\"b\", 2)\n(\"c\", 3)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>Variables.</p> required <p>Returns:</p> Name Type Description <code>Iterable</code> <code>Iterable</code> <p>The names of the variables and their underlying objects.</p>"}]}